<script>
  import {onMount, getContext} from 'svelte'

  import PayToCall from '../../components/PayToCall.html'
  import Auth from '../../components/Auth.html'
  import account from '../../components/etleneumAccountStore'

  import {
    state,
    sharePrice,
    countShares,
    calcBalance,
    capitalize
  } from './helpers'

  export let marketId

  const contract = getContext('contract')
  const marketsStore = getContext('markets')

  var market
  marketsStore.subscribe(markets => {
    if (markets[marketId]) {
      market = {id: marketId, ...markets[marketId]}
    }
  })

  var call
  onMount(() => {
    return getContext('unset-call')(() => {
      call = null
      params.type = 'buy'
      params.nshares = 1
    })
  })

  var params = {
    nshares: 1,
    side: 'yes',
    type: 'buy'
  }

  $: sharesMax =
    market &&
    (params.type === 'buy' ? 100 : market.shares[params.side][$account.id])
  $: msatoshiDiff = market && {
    buy:
      calcBalance(
        market.liquidity,
        countShares(market, 'yes') +
          (params.side === 'yes' ? params.nshares : 0),
        countShares(market, 'no') + (params.side === 'no' ? params.nshares : 0)
      ) - market.balance,
    sell:
      market.balance -
      calcBalance(
        market.liquidity,
        countShares(market, 'yes') -
          (params.side === 'yes' ? params.nshares : 0),
        countShares(market, 'no') - (params.side === 'no' ? params.nshares : 0)
      )
  }
  $: each = msatoshiDiff && msatoshiDiff[params.type] / params.nshares

  function cancel() {
    call = null
  }

  async function exchange(e) {
    e.preventDefault()

    state.update(st => {
      return st
    })

    call = await contract.prepareCall(
      'exchange',
      params.type === 'buy' ? msatoshiDiff.buy : 0,
      {
        side: params.side,
        nshares: params.nshares * (params.type === 'buy' ? 1 : -1),
        id: market.id
      },
      $account.session
    )

    state.update(st => {
      st.call = call.id
      return st
    })
  }

  function setSide(side) {
    return e => {
      e.preventDefault()
      params.side = side
    }
  }

  function toggleSell(e) {
    params.type = e.target.checked ? 'sell' : 'buy'

    if (market.shares.yes[$account.id] && !market.shares.no[$account.id]) {
      params.side = 'yes'
    } else if (
      market.shares.no[$account.id] &&
      !market.shares.yes[$account.id]
    ) {
      params.side = 'no'
    }

    params.nshares = market.shares[params.side][$account.id]
  }
</script>

<style>
  h2 {
    text-align: center;
  }
  .side-buttons {
    display: flex;
    justify-content: space-around;
  }
  .side-buttons > div {
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }
  .side-buttons small {
    display: block;
    margin: auto;
    text-align: center;
  }
  .yes {
    background-color: var(--emphasis);
    color: white;
  }
  .no {
    background-color: var(--emphasis-rare);
  }
</style>

{#if !market}
<p style="margin: 25px 20px">Loading market {marketId}...</p>
{:else if call}
<div class="call">
  <PayToCall invoice="{call.invoice}" on:cancel="{cancel}" />
</div>
{:else}
<form on:submit="{ exchange}">
  <h1>Making a bet</h1>
  <h2>{market.terms}</h2>
  {#if $account.id && (market.shares.yes[$account.id] ||
  market.shares.no[$account.id])}
  <label>
    <div>Sell?</div>
    <input
      type="checkbox"
      on:change="{toggleSell}"
      style="display: block; margin: auto;"
    />
    <small
      >You can sell your shares and cash out your profit or minimize your loss
      before the market resolves.</small
    >
  </label>
  {/if}
  <label on:click="{e => e.preventDefault()}" for="nothing">
    <div>Side</div>
    <div class="side-buttons">
      <div>
        {#if $account.id && market.shares.yes[$account.id]}
        <small>balance: {market.shares.yes[$account.id]}</small>
        {/if}
        <button
          class="yes"
          class:active="{params.side === 'yes'}"
          on:click="{setSide('yes')}"
          disabled="{params.type === 'sell' && !market.shares.yes[$account.id]}"
        >
          YES
        </button>
      </div>
      <div>
        {#if $account.id && market.shares.no[$account.id]}
        <small>balance: {market.shares.no[$account.id]}</small>
        {/if}
        <button
          class="no"
          class:active="{params.side === 'no'}"
          on:click="{setSide('no')}"
          disabled="{params.type === 'sell' && !market.shares.no[$account.id]}"
        >
          NO
        </button>
      </div>
    </div>
    <small
      ><code>YES</code> means
      <span
        >the question or statement above will be answered with a "yes" or be
        true</span
      >, <code>NO</code> means it will be false or answered with a "no".</small
    >
  </label>
  <label>
    <div>Shares to {params.type}</div>
    <input
      type="range"
      min="1"
      max="{sharesMax}"
      step="1"
      bind:value="{params.nshares}"
    />
    <small>
      If the market resolves to your side, each share is worth
      {parseInt(sharePrice / 1000)} satoshi, paid to your
      <a href="https://etleneum.com/" target="_blank">Etleneum</a> account,
      otherwise it will be worth zero.
    </small>
  </label>
  <div class="button-wrap">
    {#if !$account.id}
    <div>
      Login to your
      <a href="https://etleneum.com/" target="_blank">Etleneum</a> account to
      bet on this market.
      <Auth />
    </div>
    {/if}
    <button disabled="{!$account.id}">
      {capitalize(params.type)} {params.nshares} {params.side.toUpperCase()}
      share{#if params.nshares > 1}s{/if} for
      {Math.ceil(msatoshiDiff[params.type] / 1000)} sat{#if params.nshares > 1}
      ({Math.ceil(each / 1000)} each){/if}
    </button>
  </div>
</form>
{/if}
